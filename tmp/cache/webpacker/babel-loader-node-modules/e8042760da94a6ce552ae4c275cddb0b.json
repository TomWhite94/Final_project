{"ast":null,"code":"'use strict';\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar hasSymbols = require('has-symbols')();\n\nvar hasToStringTag = hasSymbols && _typeof(Symbol.toStringTag) === 'symbol';\nvar regexExec;\nvar isRegexMarker;\nvar badStringifier;\n\nif (hasToStringTag) {\n  regexExec = Function.call.bind(RegExp.prototype.exec);\n  isRegexMarker = {};\n\n  var throwRegexMarker = function throwRegexMarker() {\n    throw isRegexMarker;\n  };\n\n  badStringifier = {\n    toString: throwRegexMarker,\n    valueOf: throwRegexMarker\n  };\n\n  if (_typeof(Symbol.toPrimitive) === 'symbol') {\n    badStringifier[Symbol.toPrimitive] = throwRegexMarker;\n  }\n}\n\nvar toStr = Object.prototype.toString;\nvar regexClass = '[object RegExp]';\nmodule.exports = hasToStringTag // eslint-disable-next-line consistent-return\n? function isRegex(value) {\n  if (!value || _typeof(value) !== 'object') {\n    return false;\n  }\n\n  try {\n    regexExec(value, badStringifier);\n  } catch (e) {\n    return e === isRegexMarker;\n  }\n} : function isRegex(value) {\n  // In older browsers, typeof regex incorrectly returns 'function'\n  if (!value || _typeof(value) !== 'object' && typeof value !== 'function') {\n    return false;\n  }\n\n  return toStr.call(value) === regexClass;\n};","map":null,"metadata":{},"sourceType":"module"}